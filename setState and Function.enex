<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export3.dtd">
<en-export export-date="20200619T024119Z" application="Evernote" version="Evernote Mac 7.14 (458244)">
<note><title>setState and Function</title><content><![CDATA[<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd"><en-note><div style="caret-color: rgb(0, 0, 0); color: rgb(0, 0, 0); font-variant-caps: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div>[00:00:00]</div><div>&gt;&gt; Há também um pouco mais sobre this.setState. Por isso, tradicionalmente vimos que estávamos passando um objeto, você pode passar outras coisas. Nesse caso, você também pode passar uma função lá. Portanto, este é um interessante. Isso parece muito semelhante ao exemplo que tínhamos antes.</div><div><br /></div><div>[00:00:17]</div><div>Mas agora você pode ver, eu posso passar em uma função. E essa função obtém alguns argumentos, sendo o primeiro estado. E isso é passado para a função e então podemos fazer coisas com ela. Portanto, isso se parece com o anterior. Mas se usarmos essa sintaxe, alguém quer dar um palpite de sorte no que o contador será incrementado?</div><div><br /></div><div>[00:00:42]</div><div>Três certo? Porque neste caso, não é necessariamente agrupá-los, porque antes que pudéssemos mesclar objetos, certo? Às vezes, as partes mais estranhas do gerenciamento de estado no React não têm nada a ver com o React e tudo a ver com o JavaScript, certo? Você pode mesclar objetos, não pode mesclar funções.</div><div><br /></div><div>[00:00:58]</div><div>Isso não é uma coisa, certo? Você pode compor, não vamos entrar nisso, sim. Mas você pode ir em frente e pode, ele desempenhará cada uma dessas funções uma a uma. Então coloque o primeiro. Tudo bem que passou de zero para um, tocou para o segundo que passou de um para dois, tocou para o terceiro que passou de dois para três, vamos três vezes a esse ponto.</div><div><br /></div><div>[00:01:17]</div><div>Portanto, o uso de uma sintaxe um pouco diferente fornece efeitos totalmente diferentes, para um contador, mas você pode imaginar que, em uma situação de palestra, pode ser como é, eu gosto dessa nova sintaxe. Eu só vou, alguns dos piores bugs que eu já introduzi uma nova base de código, ou seja, estou influenciando algum outro recurso.</div><div><br /></div><div>[00:01:35]</div><div>Só vou refatorar isso enquanto estiver aqui, certo? Isso sempre vai muito bem. Legal, para que possamos implementá-lo dessa maneira, podemos fazer state.count, se você realmente quiser, pode desestruturá-lo e fazer valer + 1, isso realmente não importa, essas são duas maneiras diferentes de dizer a mesma coisa.</div><div><br /></div><div>[00:01:54]</div><div>De qualquer maneira, seguiremos a sintaxe que você mais gostar, vá em frente, não importa. Então, sim, como eu disse, ele toca em cada um deles. E isso permite que você faça algumas coisas interessantes também. Por ser uma função, não apenas um objeto, também podemos escrever algumas regras.</div><div><br /></div><div>[00:02:11]</div><div>Podemos seguir em frente e dizer: tudo bem, apenas incrementa até cinco, você sabe se já é maior que igual a cinco retornos, caso contrário, faça isso, certo? Portanto, isso nos dará um contador que só chega a cinco nesse caso. E você pode ter todos os tipos de tipos diferentes de lógica.</div><div><br /></div><div>[00:02:26]</div><div>Isso se torna um pouco mais interessante quando você deseja repassar as coisas, certo, se você estiver codificado e puder ter feito isso na função de renderização, e assim por diante, mas podemos prosseguir e poder então vamos jogar um pouco com esse contador agora que o temos.</div><div><br /></div><div>[00:02:41]</div><div>Então, vamos entrar no código e vamos experimentar o que vimos na tela um segundo atrás. Vamos dizer this.setState. Vamos dar uma função dessa vez. Diremos state e, nesse caso, faremos se state.count for maior ou igual a 5 e retornaremos.</div><div><br /></div><div>[00:03:05]</div><div>E vou fazer uma pausa por um momento, você perceberá que eu poderia ir em frente e dizer que count é state.count, eu poderia dizer atualizar o estado para o que já era, mas também posso se voltar indefinido disso funcione efetivamente, ele simplesmente não atualizará o estado.</div><div><br /></div><div>[00:03:23]</div><div>Uma das razões pelas quais estou chamando isso para sua atenção é porque assim não funcionará mais tarde, certo? Então isso é o que você sabe, na narrativa é como se houvesse uma arma usada no capítulo 14, é melhor estar na lareira no capítulo um. E se houver uma arma na lareira no capítulo um, é melhor usá-la no capítulo 14, certo?</div><div><br /></div><div>[00:03:39]</div><div>Então, eu estou apontando isso agora porque, como falaremos sobre isso daqui a pouco. Então, diremos que se state.count for maior que 5, basta retornar caso contrário, tudo bem, então tentaremos a versão mais simples disso. Iremos em frente e verificá-lo no incremento de incremento de incremento de aplicativo.</div><div><br /></div><div>[00:04:04]</div><div>E você pode ver que ainda posso apertar o botão, mas não vamos passar das cinco. Tudo bem, isso é legal. Agora isso se torna um pouco mais interessante se queremos passar em algum tipo de suporte. Assim, por exemplo, poderíamos passar para a aplicação e poderíamos dizer, tudo bem, contador, diremos que você tem um máximo de 5.</div><div><br /></div><div>[00:04:24]</div><div>Diremos 15. E diremos um passo de 5, certo? Para que possamos passar dados adicionais. Tudo bem, então nós passamos no máximo 15 e no passo 5. E a coisa mais óbvia a se fazer nesse caso, seria algo como Max e step = this.props.</div><div><br /></div><div>[00:04:57]</div><div>E podemos dizer, tudo bem, se é menor ou igual ao máximo, ou se é, e então incrementaremos a etapa. Vamos dar uma volta e certifique-se de cometer erros fatais. 5, 10, 15 não mais, certo? Agora, uma das coisas é que, se isso ficou um pouco mais complicado, certo, essa função que estava fazendo toda essa lógica, na verdade, mesmo um desvio padrão mais complicado, pode haver um mundo no qual queremos testar, certo ?</div><div><br /></div><div>[00:05:31]</div><div>Eu sei, selvagem. Podemos querer executar um teste de unidade. Agora, com tudo isso.props e this.state, isso se torna um pouco complicado, porque então precisamos retirar a enzima ou a biblioteca de testes React. Temos um componente de montanha e temos que passar em adereços. E então nós temos todas essas coisas.</div><div><br /></div><div>[00:05:48]</div><div>Bem quando estamos apenas tentando testar como, essa função funciona da maneira que achamos que deveria? Direita? Acontece que, além de apenas obter o estado, ele também recebe. Adereços, e assim poderíamos realmente fazer isso tudo dentro da função. Desde que this.props serão os adereços.</div><div><br /></div><div>[00:06:11]</div><div>Agora, um olhar cuidadoso notará que isso é realmente apenas uma função, como uma função regular com a qual podemos fazer qualquer coisa, certo? Então eu poderia, teoricamente, retirar isso. Poderíamos tê-lo em outro lugar onde seja uma função JavaScript antiga e regular. Você poderia teoricamente algum estado e alguns adereços, certo, e depois olhar para o valor de retorno que sai.</div><div><br /></div><div>[00:06:37]</div><div>E apenas escreva uma tarefa unitária muito, muito, muito simples, porque é apenas uma função JavaScript, e poderíamos passar aqui. Isso também é útil se você se encontrar em um aplicativo que está crescendo e você está tipo, ok, eu tenho um pouco dessa lógica complicada e depois usamos em vários lugares, certo?</div><div><br /></div><div>[00:06:53]</div><div>O que deixa você com duas opções em vários lugares, o que é uma violação de qualquer tipo de princípio semelhante do qual você já ouviu falar, certo? Porque então você também precisa se lembrar de mudar vários lugares. Ou você pode simplesmente sair e depois tem uma coisa que você pode usar em vários lugares.</div><div><br /></div><div>[00:07:07]</div><div>Assim como para nossos editores, temos como todos sabem que existe um editor de código e um editor de design. Na verdade, existem 12 editores para todos os diferentes lugares em que você pode usá-los. E eles são compostos de todas essas peças diferentes. E assim podemos mudar um lugar e passar por todas as coisas.</div><div><br /></div><div>[00:07:22]</div><div>É, você sabe, construir esses pequenos blocos de construção em vez de ter um monte de condicionais e um grande editor. Certo, então tudo funciona exatamente como antes. Mas aqui nós retiramos tudo. E essa é uma das grandes vantagens de poder usar uma função neste estado. Certo?</div><div><br /></div><div>[00:07:39]</div><div>Nós podemos ter isso. Podemos testá-lo facilmente, sem precisar montar todo o componente, e assim por diante. Certo, e vimos que se o fizermos três vezes, ele se acumulará e, portanto, se comportará um pouco diferente. Então, quando você entra assim, eu gosto desse padrão, vou refatorar, certo, assim isso pode ficar um pouco problemático, porque se o fizermos, ele passará por isso todas as três vezes.</div><div><br /></div><div>[00:08:07]</div><div><br /></div><div>&gt;&gt; A função de seta substituiria a necessidade de this.increment.bind, certo?</div><div>&gt;&gt; Portanto, temos um chamado incremento, que é apenas um tipo separado, separado fora da classe.</div><div>&gt;&gt; Ok.</div><div>&gt;&gt; Há uma sintaxe que você pode usar ao fazer isso.</div><div>&gt;&gt; É isso, sim.</div><div><br /></div><div>[00:08:26]</div><div><br /></div><div>&gt;&gt; Isso, dependendo do dia, não é suportado nativamente nos navegadores, certo? Então, o que isso faz é uma função de seta que efetivamente faz o mesmo que isso. Requer um plugue de bolha no qual você pode ou não ter em seu aplicativo. E se você apenas sim, colou, não é suportado nativamente.</div><div><br /></div><div>[00:08:45]</div><div>E há um argumento de que isso definirá uma nova função em cada instância da classe versus a outra que foi compartilhada na superclasse. Eu não me importo necessariamente com isso, porque quando pegarmos o gancho, vamos redefinir as funções em todo o lugar. É mais um problema, talvez você não tenha isso em seu aplicativo, certo, porque não é suportado nativamente.</div><div><br /></div><div>[00:09:05]</div><div>Dito isto, uma das primeiras coisas que fazemos quando estamos configurando um projeto para o Twilio é instalar esse plug-in, é isso que fazemos. Ou fizemos, agora usamos apenas ganchos. Mas sim, então isso também funcionará. Ótima pergunta.</div><div>&gt;&gt; Obrigado pela atualização.</div><div>&gt;&gt; Sim, não há problema.</div><div><br /></div></div><div><br /></div></en-note>]]></content><created>20200618T003750Z</created><updated>20200619T024055Z</updated><note-attributes><latitude>-23.64261912705359</latitude><longitude>-46.6608848522843</longitude><altitude>765.9774780273438</altitude><author>Igor Clemente</author><source>desktop.mac</source><reminder-order>0</reminder-order></note-attributes></note>
</en-export>
